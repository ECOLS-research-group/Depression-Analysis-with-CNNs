# -*- coding: utf-8 -*-
"""Data_Transformation

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Oc5iaTjddQwWmQqFFkrM6KnbzGz58yQV
"""

!pip install transformers

# Mount Google Drive
from google.colab import drive
drive.mount('/content/drive')

# Path to your file on Google Drive
file_path = "/content/drive/My Drive/merged_tensors_with_labels.csv"

# Copy the file to Colab under the /content directory
!cp "{file_path}" /content

# Load the CSV file into a DataFrame
import pandas as pd
df = pd.read_csv("/content/merged_tensors_with_labels.csv")

# Display the DataFrame
print(df.head())

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import os
import shutil
import random

# Load the CSV file from /content
file_path = "/content/merged_tensors_with_labels.csv"
df = pd.read_csv(file_path)

# Base directory to save bar graph images
output_base_dir = "/content/bargraphs"

# Remove the bargraphs folder if it exists, then create a new one
if os.path.exists(output_base_dir):
    shutil.rmtree(output_base_dir)  # Delete the folder
os.makedirs(output_base_dir, exist_ok=True)

# Function to generate and save bar graph images with a dark background and contrasting colors
def generate_bar_graph(vector, file_name):
    # Set a dark background for the plot (black background)
    plt.style.use('dark_background')

    # Downsample the vector to reduce the number of bars (e.g., every 10th value)
    vector = vector[::10]  # Select every 10th value (this reduces the number of bars)

    # Create random colors for each bar (bright colors for contrast)
    colors = [plt.cm.plasma(random.random()) for _ in range(len(vector))]  # Using the 'plasma' colormap for bright colors

    # Set the figure size to smaller dimensions
    plt.figure(figsize=(4, 2))  # Smaller output dimensions (width x height)

    # Create a bar plot
    plt.bar(range(len(vector)), vector, color=colors)  # Assign random colors
    plt.axis('off')  # Remove axis
    plt.gca().set_frame_on(False)  # Remove the frame around the graph

    # Save the image at a much lower DPI for faster image generation
    plt.savefig(file_name, bbox_inches='tight', pad_inches=0, dpi=50)  # Further reduced DPI for faster rendering
    plt.close()

# Generate bar graphs for each vector in the DataFrame and save based on label
for idx, row in df.iterrows():
    vector = row[:768].values  # Assuming first 768 columns are features
    label = row['is_depression']  # Assuming 'is_depression' is the label column

    # Define directory based on label (0 or 1)
    label_dir = os.path.join(output_base_dir, str(label))
    os.makedirs(label_dir, exist_ok=True)

    # Generate file path and save bar graph
    file_name = os.path.join(label_dir, f"bargraph_{idx}.png")
    generate_bar_graph(vector, file_name)

print("Bar graphs generated with optimized performance (faster and smaller) under:", output_base_dir)

import shutil

# Path to the output directory
output_base_dir = "/content/bargraphs"
zip_path = "/content/bargraphs.zip"

# Zip the 'bargraphs' folder
shutil.make_archive(output_base_dir, 'zip', output_base_dir)

print("Bargraphs have been zipped and saved at:", zip_path)

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import os
import shutil
from matplotlib.colors import LinearSegmentedColormap

# Load the CSV file from /content
file_path = "/content/merged_tensors_with_labels.csv"
df = pd.read_csv(file_path)

# Base directory to save heatmap images
output_base_dir = "/content/heatmaps"

# Remove the heatmaps folder if it exists, then create a new one
if os.path.exists(output_base_dir):
    shutil.rmtree(output_base_dir)  # Delete the folder
os.makedirs(output_base_dir, exist_ok=True)

# Create a custom colormap (yellow -> black -> purple)
cmap = LinearSegmentedColormap.from_list("yellow_black_purple", ["yellow", "black", "purple"])

# Function to generate and save heatmap images
def generate_heatmap(vector, file_name):
    # Pad the vector to 784 elements
    padded_vector = np.pad(vector, (0, 784 - len(vector)), mode='constant')
    reshaped_vector = padded_vector.reshape((28, 28))

    # Plot heatmap
    plt.figure(figsize=(2, 2))  # Small size for quick generation
    plt.imshow(reshaped_vector, cmap=cmap, aspect='auto')
    plt.axis('off')  # Remove axis
    plt.savefig(file_name, bbox_inches='tight', pad_inches=0)
    plt.close()

# Generate heatmaps for each vector in the DataFrame and save based on label
for idx, row in df.iterrows():
    vector = row[:768].values  # Assuming first 768 columns are features
    label = row['is_depression']  # Assuming 'is_depression' is the label column

    # Define directory based on label (0 or 1)
    label_dir = os.path.join(output_base_dir, str(label))
    os.makedirs(label_dir, exist_ok=True)

    # Generate file path and save heatmap
    file_name = os.path.join(label_dir, f"heatmap_{idx}.png")
    generate_heatmap(vector, file_name)

print("Heatmaps generated and saved in label-specific folders under:", output_base_dir)

import shutil

# Path to the output directory
output_base_dir = "/content/heatmaps"
zip_path = "/content/heatmaps.zip"

# Zip the 'heatmaps' folder
shutil.make_archive(output_base_dir, 'zip', output_base_dir)

print("Heatmaps have been zipped and saved at:", zip_path)